import User from '../models/User';
import Todo from '../models/Todo';
import Todolist from '../models/Todolist';
import errors from '../errors';
import mongoose from 'mongoose';
import BluePromise from 'bluebird';
import * as _ from 'lodash';
import notificationService from '../services/notification';
import Notification from '../models/Notification';
import log from '../config/log';

/**
 *
 */
export class TodoController {

    /**
     * ctx: {
     *    params: {
     *       todo: <wu.model.Todo> //Generated by middleware
     *    }
     * }
     * @param {object} ctx
     */
    async updateTodo(ctx) {
        const result = {};

        const todoDoc = ctx.params.todo;

        const finished = todoDoc.finished;

        const updatedFields = _.pick(ctx.request.body, ['title', 'description', 'color', 'finished']);

        if (_.isEmpty(updatedFields)) {
            ctx.status = 400;
            result.error = new Error('Need data to update Todo');
            return ctx.body = result;
        }

        Object.assign(todoDoc, updatedFields);

        try {
            const newTodoDoc = await todoDoc.save();

            result.data = [newTodoDoc.toJSON()];
        } catch(err) {
            log.error(err);
            if (err instanceof mongoose.Error.ValidationError) {
                result.error = new errors.ValidationError.fromMongooseValidationError(err);
                ctx.status = 422;
            } else {
                result.error = new Error(err.message);
                ctx.status = 500;
            }
        }

        ctx.body = result;
    }

    /**
     * ctx: {
     *    params: {
     *       todo: <wu.model.Todo>
     *    }
     * }
     * @param {object} ctx
     */
    async finishTodo(ctx) {
        const result = {};

        const todoDoc = ctx.params.todo;

        todoDoc.finished = true;

        try {
            const newTodoDoc = await todoDoc.save();

            if (todoDoc.parent) {
                const parentTodo = await Todo.findById(todoDoc.parent).exec();

                if (parentTodo) {
                    notificationService.notifyTodoFinished(parentTodo, newTodoDoc);
                }
            }

            result.data = [newTodoDoc.toJSON()];
        } catch(err) {
            log.error(err);

            if (err instanceof mongoose.Error.ValidationError) {
                result.error = errors.ValidationError.fromMongooseValidationError(err);
                ctx.status = 422;
            } else {
                result.error = new Error(err.message);
                ctx.status = 500;
            }
        }

        ctx.body = result;
    }

    /**
     * ctx: {
     *    params: {
     *       todo: <wu.model.Todo>
     *    }
     * }
     * @param {object} ctx
     */
    async acceptTodo(ctx) {
        const result = {};

        const todoDoc = ctx.params.todo;

        if (!todoDoc.parent) {
            log.error(`Try to accept parent Todo ${todoDoc._id}`);
            result.error = new Error('Only shared todos can be accepted');
            ctx.status = 400;
            ctx.body = result;
            return;
        }

        const parentTodo = await Todo.findById(todoDoc.parent).exec();

        if (!parentTodo) {
            log.error(`Try to accept Todo ${todoDoc._id} without a parent`);
            result.error = new Error('Parent todo not found');
            ctx.status = 404;
            ctx.body = result;
            return;
        }

        todoDoc.accepted = true;

        try {
            const newTodoDoc = await todoDoc.save();

            notificationService.notifyTodoAccepted(parentTodo, newTodoDoc);

            result.data = [newTodoDoc.toJSON()];
        } catch(err) {
            log.error(err);

            if (err instanceof mongoose.Error.ValidationError) {
                result.error = errors.ValidationError.fromMongooseValidationError(err);
                ctx.status = 422;
            } else {
                result.error = new Error(err.message);
                ctx.status = 500;
            }
        }

        ctx.body = result;
    }

    /**
     * ctx: {
     * params: {
     *    id: <Mongoose.Types.ObjectId>
     * }}
     * @param {object} ctx
     */
    async createTodo(ctx) {
        const result = {};

        const todolist = await Todolist.findById(ctx.params.id).exec();

        if(!todolist) {
            ctx.status = 404;
            result.error = new errors.NotFoundError('Todolist not found');
            ctx.body = result;
            return;
        }

        try {
            const data = _.pick(ctx.request.body, ['title', 'description', 'color', 'finished']);
            data.owner = ctx.user._id;
            data.todolistId = ctx.params.id;
            const todoDoc = await Todo.create(data);

            result.data = [todoDoc.toJSON()];
        } catch(err) {
            if (err instanceof mongoose.Error.ValidationError) {
                result.error = errors.ValidationError.fromMongooseValidationError(err);
                ctx.status = 422;
            } else {
                result.error = new Error(err.message);
                ctx.status = 500;
            }
        }

        ctx.body = result;
    }

    /**
     * params {
     *    id: <Mongoose.Types.ObjectId>
     * }
     * @param ctx
     */
    async deleteTodo(ctx) {
        const result = {};

        const todoDoc = ctx.params.todo;

        try {
            const removedTodo = await todoDoc.remove();
            result.data = [removedTodo];
        } catch(err) {
            result.error = new Error(err.message);
            ctx.status = 500;
        }

        ctx.body = result;
    }

    /**
     * ctx: {
     * params: {
     *    id: <todoId>,
     *    todo: <wu.model.Todo> //Generated by middleware
     * }}
     * @param ctx
     */
    async getTodo(ctx) {
        const result = {};

        const todoDoc = ctx.params.todo;

        result.data = [todoDoc];

        ctx.body = result;
    }

    /**
     * ctx: {
     *    params: {
     *       id: <todoId>,
     *       todo: <wu.model.Todo> //Generated by middleware
     *    },
     *    request: {
     *       body: {
     *          share: <Array<userId>
     *      }
     *    }
     * }
     * @param ctx
     */
    async shareTodo(ctx) {
        const result = {};

        const todoDoc = ctx.params.todo;

        if (todoDoc.finished) {
            ctx.status = 422;
            result.error = new errors.RequestDataError('Cannot share finished todo');
            ctx.body = result;
            return;
        }

        if (todoDoc.parent) {
            ctx.status = 422;
            result.error = new errors.RequestDataError('Cannot share shared todo');
            ctx.body = result;
            return;
        }

        let share = ctx.request.body.share || [];

        share = share.filter(v => mongoose.Types.ObjectId.isValid(v));

        // No self sharing? Perhaps we should put the parent todo owner to the sharing user to make everything equal
        const index = share.indexOf(todoDoc.owner);

        if (index > -1) {
            share = share.splice(index, 1);
        }

        if( _.isEmpty(share)) {
            ctx.status = 422;
            result.error = new errors.RequestDataError('Request data share should not be empty');
            ctx.body = result;
            return;
        }

        // Find the users for sharing.
        let userForShare = await User.find({
            _id: {
                $in: share
            },
            ingorelist: {
                $nin: share
            },
            friends: {
                $in: [ctx.user._id]
            }
        }).exec();

        if (_.isEmpty(userForShare)) {
            ctx.status = 404;
            result.error = new errors.NotFoundError('No valid user for sharing');
            ctx.body = result;
            return;
        }

        userForShare = userForShare.filter( (v) => todoDoc.shared.indexOf(v._id) === -1);

        const todoDocJson = todoDoc.toJSON();
        todoDocJson.parent = todoDoc._id;
        delete todoDocJson._id;

        const todos = userForShare.map(user => {
            todoDocJson.owner = user._id;
            todoDocJson.todolistId = user.defaultTodolistId;
            return todoDocJson;
        });

        if (todos.length === 0) {
            ctx.status = 204;
            result.data = [];
            ctx.body = result;
            return;
        }

        const todoDocs = await new BluePromise((resolve) => {
            Todo.collection.insert(todos, (err, doc) => {
                if (err) {
                    resolve(err);
                } else {
                    resolve(doc);
                }
            });
        });

        if (todoDocs instanceof Error) {
            ctx.status = 500;
            log.error(todoDocs);
            result.error = new Error('Unable to create shared todos');
            ctx.body = result;
            return;
        }

        const updatedTodo = await Todo.findByIdAndUpdate(todoDoc._id, {
            shared: userForShare.map( v => v._id )
        }, {new:true});

        result.data = [updatedTodo];

        ctx.body = result;
    }

    /**
     * ctx = {
     *    params: {
     *       id: <Mongoose.Types.ObjectId>
     *       uid: <Mongoose.Types.ObjectId>
     *       todo: <wu.model.Todo> //Generated by middleware
     *    }
     * }
     * @param ctx
     */
    async unShareTodo(ctx) {
        const result = {};

        const todoDoc = ctx.params.todo;

        if (todoDoc.parent) {
            ctx.status = 422;
            result.error = new errors.RequestDataError('Todo is a shared todo');
            ctx.body = result;
            return;
        }

        const sharedTodoDoc = await Todo.findOne({
            owner: ctx.params.uid,
            parent: todoDoc._id
        }).exec();

        if (!sharedTodoDoc) {
            ctx.status = 404;
            result.error = new errors.NotFoundError('Shared Todo not found');
            ctx.body = result;
            return;
        }

        const updatedTodo = await Todo.findByIdAndUpdate(todoDoc._id, {
            $pull: {
                shared: ctx.params.uid
            }
        }, {new: true}).exec();

        if (!updatedTodo) {
            log.error(`Could not unshare todo ${todoDoc._id} with user ${ctx.params.uid}`);
        }

        const updatedSharedTodo = await Todo.update({
            _id: sharedTodoDoc._id
        }, {
            parent: null
        });

        if (!updatedSharedTodo.ok) {
            log.error(`Could not unshare shared todo ${sharedTodoDoc._id} with user ${ctx.params.uid}`);
        }

        result.data = [updatedTodo];

        ctx.body = result;
    }
}

export default new TodoController();